package EPrints::Plugin::CoreAdditional;

use strict;

our @ISA = qw/ EPrints::Plugin /;


##################################
package EPrints::Script::Compiled;
##################################

#JM: to render names linking to the proper view entry when an lshtmid is found
sub run_label_link
{
	my( $self, $state, $comp ) = @_;

	if( !defined $comp->[1] ){
		$self->runtime_error( "Can only call label_link() on a field with type 'compound' " );
	}
	if( ref($comp->[1]) ne "EPrints::MetaField::Compound" ){
		$self->runtime_error( "Can only call label_link() on a field with type 'compound' ".ref($comp->[1]) );
	}

	my $f = $comp->[1]->get_property( "fields_cache" );
	
	my $lshtmid = $comp->[0]->{lshtmid};
	
	my $name_field;
	
	foreach my $field_conf ( @{$f} )
	{
		if( $field_conf->{name} =~ /^[a-z]+_name$/i ){
		  # this will match creators_name, editors_name, etc
		  $name_field = $field_conf;
		}
	}
	unless(defined $name_field)
	{
		$self->runtime_error( "Can only call label_link() on compound with a sub field named '[a-z]+_name'" );
	}
	
	my $rendered_name = $name_field->get_value_label($state->{session}, $comp->[0]->{name});
	my $returned_name = $rendered_name;
	
  if ($lshtmid)
  {
    # if an lshtmid value is found we link to the view page
    my $repo = $state->{session}->get_repository;
    
    my $view_id = $repo->config( "creators_view_id" );
    my $url .= $repo->config( "base_url" ).'/view/'.$view_id.'/'.EPrints::Utils::escape_filename( $lshtmid ).'.html';
    	
    my $span = $repo->make_element( "span", class => "lshtm_name" );
    my $a = $repo->render_link( $url );
    $a->appendChild( $rendered_name );
    $span->appendChild( $a );
    
    $returned_name = $span;
  }

  return [$returned_name, "XHTML"];
}


###############################
package EPrints::Update::Views;
###############################

sub ULCC_group_by_a_to_z
{ 
	my $grouping = group_by_n_chars( @_, 1 ); 
	foreach my $c ( 'A'..'Z' )
	{
		next if defined $grouping->{$c};
		$grouping->{$c} = [];
	}
	
	#JM: the additional bit to get rid of the '?' generated by zero-length values at group_by_n_chars
	delete $grouping->{'?'} if $grouping->{'?'};
	
	return $grouping;
}
